#!/usr/bin/env escript

-mode(compile).

main([File, ModuleName]) ->
    case filelib:is_regular(File) of
        false ->
            usage(),
            halt(1);
        _ -> ok
    end,
    {ok, Bin} = file:read_file(File),
    ok = process(Bin, ModuleName);
main([]) ->
    application:ensure_all_started(ssl),
    inets:start(),
    Url = "https://www.unicode.org/Public/security/latest/confusables.txt",
    {ok, {{_, 200, _}, _Headers, Body}} = httpc:request(Url),
    Bin = iolist_to_binary(Body),
    ok = process(Bin, "tr39").

usage() ->
    io:format("Usage: ./generate [/path/to/confusables.txt] [module_name]").

process(Bin0, ModuleName) ->
    {utf8, Len} = unicode:bom_to_encoding(Bin0),
    Bin = binary:part(Bin0, Len, size(Bin0) - Len),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    Lines2 = lists:filter(fun is_not_comment_or_empty/1, Lines),

    Mapping = make_map(Lines2),
    Clauses = make_clauses(maps:next(maps:iterator(Mapping))),
    LastClause = "p(C) -> C.\n",

    OutBin = iolist_to_binary([preamble(ModuleName), Clauses, LastClause]),
    ModFileName = io_lib:format("src/~s.erl", [ModuleName]),
    file:write_file(ModFileName, OutBin),

    TestCase = test_case(make_pairs(Lines2), ModuleName),
    TestOutBin = iolist_to_binary([test_preamble(ModuleName), TestCase]),
    TestFileName = io_lib:format("test/~s_test.erl", [ModuleName]),
    file:write_file(TestFileName, TestOutBin),
    ok.

is_not_comment_or_empty(<<>>) -> false;
is_not_comment_or_empty(<<"#", _Rest/binary>>) -> false;
is_not_comment_or_empty(_) -> true.

make_pairs(Lines) -> make_pairs(Lines, []).
make_pairs([], Acc) -> lists:reverse(Acc);
make_pairs([Line | Rest], Acc) ->
    [C1Glyph, C2Bin | _] = binary:split(Line, <<";">>, [global, trim_all]),
    C1 = binary_to_integer(string:trim(C1Glyph), 16),
    C2Glyphs = binary:split(C2Bin, [<<" ">>, <<"\t">>], [global, trim_all]),
    C2 = [binary_to_integer(Hex, 16) || Hex <- C2Glyphs],
    make_pairs(Rest, [{C1, C2} | Acc]).

make_map(Lines) -> make_map(Lines, #{}).
make_map([], Acc) -> Acc;
make_map([Line | Rest], Acc) ->
    [C1, C2 | _] = binary:split(Line, <<";">>, [global, trim_all]),
    Key = binary_to_integer(string:trim(C1), 16),
    Val = base16lits(C2),
    Acc2 = case Acc of
        #{Key := {Val, Ls}} ->
            Acc#{Key => {Val, Ls ++ [Line]}};
        #{Key := {Val2, _}} ->
            exit({duplicate_detected, Key, Val, Val2});
        _ ->
            Acc#{Key => {Val, [Line]}}
    end,
    make_map(Rest, Acc2).

make_clauses(It) -> make_clauses(It, []).
make_clauses(none, Acc) -> lists:reverse(Acc);
make_clauses({K, {V, Lines}, It}, Acc) ->
    Comments = [[$%, $ , Line, $\n] || Line <- Lines],
    Fmt = "p(16#~.16b) -> ~s;~n",
    Clause = io_lib:format(Fmt, [K, V]),
    Res = [Comments, Clause],
    make_clauses(maps:next(It), [Res | Acc]).

base16lits(Codes) ->
    Split = binary:split(Codes, [<<" ">>, <<"\t">>], [global, trim_all]),
    Bins = [<<"16#", C/binary>> || C <- Split],
    case Bins of
        [_] -> Bins;
        _ -> [$[, lists:join(", ", Bins), $]]
    end.

preamble(ModuleName) ->
["%% coding: utf-8
-module(", ModuleName, ").
-export([skeleton/1, confusable/2]).

confusable(S1, S2) ->
    skeleton(S1) =:= skeleton(S2).

-spec skeleton(unicode:unicode_binary() | string()) -> [char() | [char()]].

skeleton(B) when is_binary(B) ->
    unicode:characters_to_binary([p(Char) || <<Char/utf8>> <= B]);
skeleton(S) when is_list(S) ->
    unicode:characters_to_binary([p(Char) || Char <- S]).

%% the rest of this file is automatically generated.

"].

test_preamble(ModuleName) ->
["
%% coding: utf-8
-module(", ModuleName, "_test).
-include_lib(\"eunit/include/eunit.hrl\").

"].

test_case(Pairs, ModuleName) ->
    Prologue =
["
basic_confusable_test() ->
    Latin = <<\"scope\">>,
    Cyrillic = unicode:characters_to_nfd_binary(\"ѕсоре\"),
    ?assert(Latin =/= Cyrillic),
    ?assert(unicode:characters_to_nfd_list(Latin) =/= unicode:characters_to_nfd_list(Cyrillic)),
    ?assert(", ModuleName, ":confusable(Latin, Cyrillic)).

"],

    AllCharsAssertions0 = [make_assertion(C1, C2, ModuleName) || {C1, C2} <- Pairs],
    AllCharsAssertions = string:join(AllCharsAssertions0, ",\n"),

    AllChars = ["all_chars_confusable_test() ->\n", AllCharsAssertions, "."],

    unicode:characters_to_binary([Prologue, AllChars]).

make_assertion(C1, C2, ModuleName) ->
    Actual = <<C1/utf8>>,
    Expected = unicode:characters_to_binary(C2),
    io_lib:format("    true = ~s:confusable(~w, ~w)", [ModuleName, Actual, Expected]).
