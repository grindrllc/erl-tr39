#!/usr/bin/env escript

-mode(compile).

main([File]) ->
    case filelib:is_regular(File) of
        false ->
            usage(),
            halt(1);
        _ -> ok
    end,
    {ok, Bin} = file:read_file(File),
    ok = process(Bin);
main([]) ->
    application:ensure_all_started(ssl),
    inets:start(),
    Url = "https://www.unicode.org/Public/security/latest/confusables.txt",
    {ok, {{_, 200, _}, _Headers, Body}} = httpc:request(Url),
    Bin = iolist_to_binary(Body),
    ok = process(Bin).

usage() ->
    io:format("Usage: ./generate [/path/to/confusables.txt]").

process(Bin0) ->
    {utf8, Len} = unicode:bom_to_encoding(Bin0),
    Bin = binary:part(Bin0, Len, size(Bin0) - Len),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    Lines2 = lists:filter(fun is_not_comment_or_empty/1, Lines),

    Mapping = make_map(Lines2),
    Clauses = make_clauses(maps:next(maps:iterator(Mapping))),
    LastClause = "p(C) -> [C].\n",

    OutBin = iolist_to_binary([preamble(), Clauses, LastClause]),
    file:write_file("src/tr39.erl", OutBin),

    TestCase = test_case(make_pairs(Lines2)),
    TestOutBin = iolist_to_binary([test_preamble(), TestCase]),
    file:write_file("test/tr39_test.erl", TestOutBin),
    ok.

is_not_comment_or_empty(<<>>) -> false;
is_not_comment_or_empty(<<"#", _Rest/binary>>) -> false;
is_not_comment_or_empty(_) -> true.

make_pairs(Lines) -> make_pairs(Lines, []).
make_pairs([], Acc) -> lists:reverse(Acc);
make_pairs([Line | Rest], Acc) ->
    [C1Glyph, C2Bin | _] = binary:split(Line, <<";">>, [global, trim_all]),
    C1 = binary_to_integer(string:trim(C1Glyph), 16),
    C2Glyphs = binary:split(C2Bin, [<<" ">>, <<"\t">>], [global, trim_all]),
    C2 = [binary_to_integer(Hex, 16) || Hex <- C2Glyphs],
    make_pairs(Rest, [{C1, C2} | Acc]).

make_map(Lines) -> make_map(Lines, #{}).
make_map([], Acc) -> Acc;
make_map([Line | Rest], Acc) ->
    [C1, C2 | _] = binary:split(Line, <<";">>, [global, trim_all]),
    Key = binary_to_integer(string:trim(C1), 16),
    Val = base16lits(C2),
    Acc2 = case Acc of
        #{Key := {Val, Ls}} ->
            Acc#{Key => {Val, Ls ++ [Line]}};
        #{Key := {Val2, _}} ->
            exit({duplicate_detected, Key, Val, Val2});
        _ ->
            Acc#{Key => {Val, [Line]}}
    end,
    make_map(Rest, Acc2).

make_clauses(It) -> make_clauses(It, []).
make_clauses(none, Acc) -> lists:reverse(Acc);
make_clauses({K, {V, Lines}, It}, Acc) ->
    Comments = [[$%, $ , Line, $\n] || Line <- Lines],
    Fmt = "p(16#~.16b) -> ~s;~n",
    Clause = io_lib:format(Fmt, [K, V]),
    Res = [Comments, Clause],
    make_clauses(maps:next(It), [Res | Acc]).

base16lits(Codes) ->
    Split = binary:split(Codes, [<<" ">>, <<"\t">>], [global, trim_all]),
    Bins = [<<"16#", C/binary>> || C <- Split],
    [$[, lists:join(", ", Bins), $]].

preamble() ->
"%% coding: utf-8
-module(tr39).
-export([skeleton/1, confusable/2]).

confusable(S1, S2) ->
    skeleton(S1) =:= skeleton(S2).

skeleton(S) -> nfd(<< <<Protos/utf8>> || <<C/utf8>> <= S, Protos <- p(C) >>).

nfd(Bin) when is_binary(Bin) -> unicode:characters_to_nfd_binary(Bin).

%% the rest of this file is automatically generated.

".

test_preamble() ->
"
%% coding: utf-8
-module(tr39_test).
-include_lib(\"eunit/include/eunit.hrl\").

".

test_case(Pairs) ->
    Prologue =
"
basic_confusable_test() ->
    Latin = <<\"scope\">>,
    Cyrillic = unicode:characters_to_nfd_binary(\"ѕсоре\"),
    ?assert(Latin =/= Cyrillic),
    ?assert(unicode:characters_to_nfd_list(Latin) =/= unicode:characters_to_nfd_list(Cyrillic)),
    ?assert(tr39:confusable(Latin, Cyrillic)).

",

    AllCharsAssertions0 = [make_assertion(C1, C2) || {C1, C2} <- Pairs],
    AllCharsAssertions = string:join(AllCharsAssertions0, ",\n"),

    AllChars = ["all_chars_confusable_test() ->\n", AllCharsAssertions, "."],

    unicode:characters_to_binary([Prologue, AllChars]).

make_assertion(C1, C2) ->
    Actual = <<C1/utf8>>,
    Expected = unicode:characters_to_binary(C2),
    io_lib:format("    true = tr39:confusable(~w, ~w)", [Actual, Expected]).
