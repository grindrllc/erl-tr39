#!/usr/bin/env escript

-mode(compile).

main([File, ModuleName]) ->
    case filelib:is_regular(File) of
        false ->
            usage(),
            halt(1);
        _ -> ok
    end,
    {ok, Bin} = file:read_file(File),
    ok = process(Bin, ModuleName);
main([]) ->
    application:ensure_all_started(ssl),
    inets:start(),
    Url = "https://www.unicode.org/Public/security/latest/confusables.txt",
    {ok, {{_, 200, _}, _Headers, Body}} = httpc:request(Url),
    Bin = iolist_to_binary(Body),
    ok = process(Bin, "tr39").

usage() ->
    io:format("Usage: ./generate [/path/to/confusables.txt module_name]").

process(Bin0, ModuleName) ->
    {utf8, Len} = unicode:bom_to_encoding(Bin0),
    Bin = binary:part(Bin0, Len, size(Bin0) - Len),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    Lines2 = lists:filter(fun is_not_comment_or_empty/1, Lines),

    Clauses = make_clauses(Lines2),

    OutBin = iolist_to_binary([preamble(ModuleName), Clauses]),
    ModFileName = io_lib:format("src/~s.erl", [ModuleName]),
    file:write_file(ModFileName, OutBin),

    TestCase = test_case(make_pairs(Lines2), ModuleName),
    TestOutBin = iolist_to_binary([test_preamble(ModuleName), TestCase]),
    TestFileName = io_lib:format("test/~s_test.erl", [ModuleName]),
    file:write_file(TestFileName, TestOutBin),
    ok.

is_not_comment_or_empty(<<>>) -> false;
is_not_comment_or_empty(<<"#", _Rest/binary>>) -> false;
is_not_comment_or_empty(_) -> true.

make_pairs(Lines) -> make_pairs(Lines, []).
make_pairs([], Acc) -> lists:reverse(Acc);
make_pairs([Line | Rest], Acc) ->
    [C1Glyph, C2Bin | _] = binary:split(Line, <<";">>, [global, trim_all]),
    C1 = binary_to_integer(string:trim(C1Glyph), 16),
    C2Glyphs = binary:split(C2Bin, [<<" ">>, <<"\t">>], [global, trim_all]),
    C2 = [binary_to_integer(Hex, 16) || Hex <- C2Glyphs],
    make_pairs(Rest, [{C1, C2} | Acc]).

make_clauses(Lines) -> make_clauses(Lines, []).
make_clauses([], Acc) -> lists:reverse(["p(C) -> C.\n" | Acc]);
make_clauses([Line | Rest], Acc) ->
    [C1, C2 | _] = binary:split(Line, <<";">>, [global, trim_all]),
    Source = binary_to_integer(string:trim(C1), 16),
    TargetCPs = binary:split(C2, [<<" ">>, <<"\t">>], [global, trim_all]),
    Target = case [<<"16#", CP/binary>> || CP <- TargetCPs] of
        Res = [_] -> Res;
        Res -> [$[, lists:join(", ", Res), $]]
    end,
    Fmt = "p(16#~.16b) -> ~s;~n",
    Clause = io_lib:format(Fmt, [Source, Target]),
    Comment = ["% ", Line],
    make_clauses(Rest, [[Comment, "\n", Clause] | Acc]).

preamble(ModuleName) ->
["%% coding: utf-8
-module(", ModuleName, ").
-export([skeleton/1, confusable/2]).

confusable(S1, S2) ->
    skeleton(S1) =:= skeleton(S2).

-spec skeleton(unicode:unicode_binary() | string()) -> [char() | [char()]].

skeleton(B) when is_binary(B) ->
    unicode:characters_to_binary([p(Char) || <<Char/utf8>> <= B]);
skeleton(S) when is_list(S) ->
    unicode:characters_to_binary([p(Char) || Char <- S]).

%% the rest of this file is automatically generated.

"].

test_preamble(ModuleName) ->
["
%% coding: utf-8
-module(", ModuleName, "_test).
-include_lib(\"eunit/include/eunit.hrl\").

"].

test_case(Pairs, ModuleName) ->
    Prologue =
["
basic_confusable_test() ->
    Latin = <<\"scope\">>,
    Cyrillic = unicode:characters_to_nfd_binary(\"ѕсоре\"),
    ?assert(Latin =/= Cyrillic),
    ?assert(unicode:characters_to_nfd_list(Latin) =/= unicode:characters_to_nfd_list(Cyrillic)),
    ?assert(", ModuleName, ":confusable(Latin, Cyrillic)).

"],

    AllCharsAssertions0 = [make_assertion(C1, C2, ModuleName) || {C1, C2} <- Pairs],
    AllCharsAssertions = string:join(AllCharsAssertions0, ",\n"),

    AllChars = ["all_chars_confusable_test() ->\n", AllCharsAssertions, "."],

    unicode:characters_to_binary([Prologue, AllChars]).

make_assertion(C1, C2, ModuleName) ->
    Actual = <<C1/utf8>>,
    Expected = unicode:characters_to_binary(C2),
    io_lib:format("    true = ~s:confusable(~w, ~w)", [ModuleName, Actual, Expected]).

